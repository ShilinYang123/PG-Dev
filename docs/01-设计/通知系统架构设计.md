# PMC通知系统架构设计

## 1. 系统概述

基于前期技术调研，PMC通知系统采用模块化设计，支持多种通知渠道，具备高可靠性和可扩展性。

### 1.1 设计原则
- **可靠性**：确保重要通知必达，支持失败重试和状态跟踪
- **可扩展性**：支持多种通知渠道，便于后续扩展
- **合规性**：优先使用企业微信等官方API，确保合规安全
- **性能**：异步处理，不阻塞主业务流程

### 1.2 技术选型
- **主要通知渠道**：企业微信API + 企业微信群机器人
- **备用通知渠道**：邮件、短信（预留接口）
- **消息队列**：基于Python asyncio的内存队列
- **数据存储**：SQLite（通知记录和状态）

## 2. 系统架构

### 2.1 整体架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   PMC业务模块   │───▶│   通知调度器     │───▶│   通知渠道管理   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                              │                        │
                              ▼                        ▼
                       ┌─────────────────┐    ┌─────────────────┐
                       │   消息队列       │    │   企业微信API    │
                       └─────────────────┘    └─────────────────┘
                              │                        │
                              ▼                        ▼
                       ┌─────────────────┐    ┌─────────────────┐
                       │   重试机制       │    │   群机器人API    │
                       └─────────────────┘    └─────────────────┘
                              │                        │
                              ▼                        ▼
                       ┌─────────────────┐    ┌─────────────────┐
                       │   状态跟踪       │    │   邮件/短信     │
                       └─────────────────┘    └─────────────────┘
```

### 2.2 核心组件

#### 2.2.1 通知调度器 (NotificationScheduler)
- **职责**：接收通知请求，路由到合适的通知渠道
- **功能**：
  - 通知请求解析和验证
  - 渠道选择和负载均衡
  - 优先级管理
  - 批量处理优化

#### 2.2.2 消息队列 (MessageQueue)
- **职责**：异步处理通知请求，避免阻塞主流程
- **功能**：
  - 异步消息处理
  - 优先级队列
  - 消息持久化（可选）
  - 流量控制

#### 2.2.3 通知渠道管理 (ChannelManager)
- **职责**：管理各种通知渠道的实现
- **功能**：
  - 渠道注册和发现
  - 渠道健康检查
  - 渠道切换和故障转移
  - 配置管理

#### 2.2.4 重试机制 (RetryManager)
- **职责**：处理发送失败的通知，实现智能重试
- **功能**：
  - 指数退避重试
  - 最大重试次数限制
  - 失败原因分析
  - 死信队列处理

#### 2.2.5 状态跟踪 (StatusTracker)
- **职责**：跟踪通知发送状态，提供查询接口
- **功能**：
  - 发送状态记录
  - 统计分析
  - 历史查询
  - 监控告警

## 3. 数据模型

### 3.1 通知记录表 (notifications)

```sql
CREATE TABLE notifications (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    message_id VARCHAR(64) UNIQUE NOT NULL,
    title VARCHAR(255) NOT NULL,
    content TEXT NOT NULL,
    channel VARCHAR(50) NOT NULL,
    target VARCHAR(255) NOT NULL,
    priority INTEGER DEFAULT 1,
    status VARCHAR(20) DEFAULT 'pending',
    retry_count INTEGER DEFAULT 0,
    max_retries INTEGER DEFAULT 3,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    sent_at TIMESTAMP NULL,
    error_message TEXT NULL
);
```

### 3.2 通知模板表 (notification_templates)

```sql
CREATE TABLE notification_templates (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    template_name VARCHAR(100) UNIQUE NOT NULL,
    title_template VARCHAR(255) NOT NULL,
    content_template TEXT NOT NULL,
    channel VARCHAR(50) NOT NULL,
    variables JSON NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 3.3 通知配置表 (notification_configs)

```sql
CREATE TABLE notification_configs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    config_key VARCHAR(100) UNIQUE NOT NULL,
    config_value TEXT NOT NULL,
    description TEXT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 4. 接口设计

### 4.1 核心接口

#### 4.1.1 通知发送接口

```python
class NotificationService:
    async def send_notification(
        self,
        title: str,
        content: str,
        channel: str,
        target: str,
        priority: int = 1,
        template_vars: Dict[str, Any] = None
    ) -> str:
        """发送通知
        
        Args:
            title: 通知标题
            content: 通知内容
            channel: 通知渠道 (wechat_api, wechat_bot, email, sms)
            target: 目标地址 (用户ID、群ID、邮箱等)
            priority: 优先级 (1-5, 1最高)
            template_vars: 模板变量
            
        Returns:
            message_id: 消息ID
        """
        pass
    
    async def send_template_notification(
        self,
        template_name: str,
        target: str,
        variables: Dict[str, Any]
    ) -> str:
        """使用模板发送通知"""
        pass
    
    async def get_notification_status(self, message_id: str) -> Dict[str, Any]:
        """查询通知状态"""
        pass
```

#### 4.1.2 渠道接口

```python
class NotificationChannel(ABC):
    @abstractmethod
    async def send(
        self,
        title: str,
        content: str,
        target: str
    ) -> Tuple[bool, str]:
        """发送通知
        
        Returns:
            (success, error_message)
        """
        pass
    
    @abstractmethod
    async def health_check(self) -> bool:
        """健康检查"""
        pass
```

### 4.2 企业微信渠道实现

#### 4.2.1 企业微信API渠道

```python
class WeChatAPIChannel(NotificationChannel):
    def __init__(self, corp_id: str, corp_secret: str):
        self.corp_id = corp_id
        self.corp_secret = corp_secret
        self.access_token = None
        self.token_expires_at = None
    
    async def send(
        self,
        title: str,
        content: str,
        target: str
    ) -> Tuple[bool, str]:
        """通过企业微信API发送消息"""
        pass
    
    async def get_access_token(self) -> str:
        """获取访问令牌"""
        pass
```

#### 4.2.2 企业微信群机器人渠道

```python
class WeChatBotChannel(NotificationChannel):
    def __init__(self, webhook_url: str):
        self.webhook_url = webhook_url
    
    async def send(
        self,
        title: str,
        content: str,
        target: str = None
    ) -> Tuple[bool, str]:
        """通过群机器人发送消息"""
        pass
```

## 5. 配置管理

### 5.1 环境变量配置

```env
# 企业微信配置
WECHAT_CORP_ID=your_corp_id
WECHAT_CORP_SECRET=your_corp_secret
WECHAT_AGENT_ID=your_agent_id

# 群机器人配置
WECHAT_BOT_WEBHOOK=your_webhook_url

# 通知系统配置
NOTIFICATION_QUEUE_SIZE=1000
NOTIFICATION_MAX_RETRIES=3
NOTIFICATION_RETRY_DELAY=60
NOTIFICATION_BATCH_SIZE=10

# 数据库配置
NOTIFICATION_DB_PATH=data/notifications.db
```

### 5.2 YAML配置文件

```yaml
notification:
  channels:
    wechat_api:
      enabled: true
      priority: 1
      rate_limit: 100  # 每分钟最大发送数
      timeout: 30
    wechat_bot:
      enabled: true
      priority: 2
      rate_limit: 20
      timeout: 10
    email:
      enabled: false
      priority: 3
  
  retry:
    max_attempts: 3
    base_delay: 60
    max_delay: 3600
    backoff_factor: 2
  
  templates:
    production_alert:
      title: "生产异常告警"
      content: "项目：{project_name}\n异常：{alert_message}\n时间：{timestamp}"
      channel: wechat_api
    meeting_reminder:
      title: "会议提醒"
      content: "会议：{meeting_title}\n时间：{meeting_time}\n地点：{location}"
      channel: wechat_bot
```

## 6. 部署和监控

### 6.1 部署架构
- **单机部署**：适用于中小规模PMC系统
- **容器化部署**：使用Docker进行标准化部署
- **高可用部署**：多实例部署，共享数据库

### 6.2 监控指标
- **发送成功率**：各渠道的消息发送成功率
- **响应时间**：消息发送的平均响应时间
- **队列长度**：待处理消息队列的长度
- **重试次数**：失败重试的统计信息
- **错误率**：各类错误的发生频率

### 6.3 告警机制
- **发送失败告警**：连续发送失败时触发
- **队列积压告警**：队列长度超过阈值时触发
- **渠道异常告警**：渠道健康检查失败时触发
- **配置错误告警**：配置验证失败时触发

## 7. 安全考虑

### 7.1 认证和授权
- **API密钥管理**：安全存储和轮换企业微信API密钥
- **访问控制**：限制通知发送的权限
- **审计日志**：记录所有通知操作的审计信息

### 7.2 数据保护
- **敏感信息脱敏**：通知内容中的敏感信息处理
- **数据加密**：存储和传输过程中的数据加密
- **数据清理**：定期清理过期的通知记录

### 7.3 防护措施
- **频率限制**：防止通知轰炸
- **内容过滤**：过滤恶意或不当内容
- **异常检测**：检测异常的通知模式

## 8. 实施计划

### 8.1 第一阶段：基础框架
1. 创建notification模块结构
2. 实现核心接口和抽象类
3. 建立数据库模型
4. 实现基础的消息队列

### 8.2 第二阶段：企业微信集成
1. 实现企业微信API渠道
2. 实现企业微信群机器人渠道
3. 添加配置管理
4. 实现基础的重试机制

### 8.3 第三阶段：完善功能
1. 实现模板系统
2. 添加状态跟踪
3. 实现监控和告警
4. 性能优化和测试

### 8.4 第四阶段：集成和部署
1. 与PMC业务模块集成
2. 配置生产环境
3. 用户培训和文档
4. 上线和运维支持

## 9. 风险评估

### 9.1 技术风险
- **API变更风险**：企业微信API可能发生变更
- **性能风险**：大量通知可能影响系统性能
- **依赖风险**：第三方服务的可用性风险

### 9.2 业务风险
- **合规风险**：通知内容可能涉及敏感信息
- **用户体验风险**：过多通知可能影响用户体验
- **运维风险**：系统故障可能导致重要通知丢失

### 9.3 缓解措施
- **版本兼容性**：保持API版本兼容性
- **性能测试**：充分的性能测试和优化
- **多渠道备份**：实现多渠道故障转移
- **监控告警**：完善的监控和告警机制

---

**文档版本**：v1.0  
**创建时间**：2025年1月20日  
**更新时间**：2025年1月20日  
**负责人**：雨俊  
**审核人**：杨老师